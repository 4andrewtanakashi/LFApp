<resources>
    <string name="app_name">LFApp_01</string>

    <string name="hello_world" />
    <string name="action_settings">Settings</string>
    <string name="type">Tipo</string>
    <string name="leftSide">u</string>
    <string name="rightSide">v</string>
    <string name="gr">Gramática Regular</string>
    <string name="gr_u">u ∈ V</string>
    <string name="gr_v">v ∈ λ | Σ | ΣV</string>
    <string name="glc">Gramática Livre de Contexto</string>
    <string name="glc_u">u ∈ V</string>
    <string name="glc_v">v ∈ (V ∪ Σ)∗</string>
    <string name="gsc">Gramática Sensível ao Contexto</string>
    <string name="gsc_u">u ∈ (V ∪ Σ)+</string>
    <string name="gsc_v">v ∈ (V ∪ Σ)+</string>
    <string name="gsc_condition">|u| ≤ |v|</string>
    <string name="gi">Gramática Irrestrita</string>
    <string name="gi_u">u ∈ (V ∪ Σ)+</string>
    <string name="gi_v">v ∈ (V ∪ Σ)*</string>
    <string name="logo_ufla">Logo UFLA</string>
    <string name="team">
        Carlos Pereira\n
        carloshpereira27 (at) gmail.com\n\n
        Juventino Neto\n
        jneto (at) computacao.ufla.br\n\n
        Ricardo Terra\n
        terra (at) dcc.ufla.br
    </string>
    <string name="team_html">
        &lt;font size="18"&gt;&lt;b&gt;Carlos Pereira&lt;/b&gt;&lt;/font&gt;&lt;br /&gt;
        &lt;font size="15"&gt;carloshpereira27 (at) gmail.com&lt;/font&gt;&lt;br /&gt;&lt;br /&gt;
        &lt;b&gt;&lt;font size="18"&gt;Juventino Neto&lt;/font&gt;&lt;/b&gt;&lt;br /&gt;
        &lt;font size="15"&gt;jneto (at) computacao.ufla.br&lt;/font&gt;&lt;br /&gt;&lt;br /&gt;
        &lt;b&gt;&lt;font size="18"&gt;Ricardo Terra&lt;/font&gt;&lt;/b&gt;&lt;br /&gt;
        &lt;font size="15"&gt;terra (at) dcc.ufla.br&lt;/font&gt;
    </string>
    <string name="lfapp_icon">LFApp Icon</string>
    <string name="close">Close</string>
    <string name="gramatica">Gramática:</string>
    <string name="palavra_para_cyk_e_deriva_o">Palavra (caso se queira verificar aceitações e derivações):</string>
    <string name="lambda">λ</string>
    <string name="arrow"><![CDATA[->]]></string>
    <string name="pipe">|</string>
    <string name="ok">OK</string>
    <string name="about_button">About button.</string>
    <string name="removing_left_recursive_algol_p1">
        (2) Remover as recursões em ordem:&lt;br/&gt;
        &lt;b&gt;ALGORITMO&lt;/b&gt;&lt;br/&gt;
        &lt;b&gt;para&lt;/b&gt; i = 1 até n &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;se&lt;/b&gt; A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; possui recursão direta à esquerda &lt;b&gt;então&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 elimine a recursão em A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;para&lt;/b&gt; j = i+1 até n &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;para&lt;/b&gt; cada produção em A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;se&lt;/b&gt; A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&#947; &lt;b&gt;então&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 substitua A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&#947;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 por A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; &#948;&lt;sub&gt;&lt;small&gt;1&lt;/sub&gt;&lt;/small&gt;&#947; | &#948;&lt;sub&gt;&lt;small&gt;2&lt;/sub&gt;&lt;/small&gt;&#947; | ... | &#948;&lt;sub&gt;&lt;small&gt;k&lt;/sub&gt;&lt;/small&gt;&#947;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 onde A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; -&gt; &#948;&lt;sub&gt;&lt;small&gt;1&lt;/sub&gt;&lt;/small&gt; | &#948;&lt;sub&gt;&lt;small&gt;2&lt;/sub&gt;&lt;/small&gt; | ... | &#948;&lt;sub&gt;&lt;small&gt;k&lt;/sub&gt;&lt;/small&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 são todas as produções atuais de A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
    </string>
    <string name="removing_left_recursive_algol_p2">
        (1) Remover regras do tipo
        A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&#947;,
        na ordem inversa da utilizada para remover recursão à esquerda:&lt;br/&gt;
        &lt;b&gt;ALGORITMO&lt;/b&gt;&lt;br/&gt;
        &lt;b&gt;para&lt;/b&gt; i = n até 1 &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;para&lt;/b&gt; j = i-1 até 1 &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;para&lt;/b&gt; cada produção em A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;se&lt;/b&gt; A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&#947; &lt;b&gt;então&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 substitua A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&#947;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 por A&lt;sub&gt;&lt;small&gt;j&lt;/sub&gt;&lt;/small&gt; -&gt; &#948;&lt;sub&gt;&lt;small&gt;1&lt;/sub&gt;&lt;/small&gt;&#947; | &#948;&lt;sub&gt;&lt;small&gt;2&lt;/sub&gt;&lt;/small&gt;&#947; | ... | &#948;&lt;sub&gt;&lt;small&gt;k&lt;/sub&gt;&lt;/small&gt;&#947;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 onde A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; -&gt; &#948;&lt;sub&gt;&lt;small&gt;1&lt;/sub&gt;&lt;/small&gt; | &#948;&lt;sub&gt;&lt;small&gt;2&lt;/sub&gt;&lt;/small&gt; | ... | &#948;&lt;sub&gt;&lt;small&gt;k&lt;/sub&gt;&lt;/small&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 são todas as produções atuais de A&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
    </string>
    <string name="removing_left_recursive_algol_p3">
        (2) Remover regras do tipo Z&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; -&gt; V&#947; nas variáveis criadas pelo algoritmo de remoção de recursão à esquerda, em
        ordem:&lt;br/&gt;
        &lt;b&gt;ALGORITMO&lt;/b&gt;&lt;br/&gt;
        &lt;b&gt;para&lt;/b&gt; i = 1 até n &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;para&lt;/b&gt; cada produção em Z&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; &lt;b&gt;faça&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;se&lt;/b&gt; Z&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; -&gt; V&#947; &lt;b&gt;então&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 substitua Z&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; -&gt; V&#947;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 por Z&lt;sub&gt;&lt;small&gt;i&lt;/sub&gt;&lt;/small&gt; -&gt; &#948;&lt;sub&gt;&lt;small&gt;1&lt;/sub&gt;&lt;/small&gt;&#947; | &#948;&lt;sub&gt;&lt;small&gt;2&lt;/sub&gt;&lt;/small&gt;&#947; | ... | &#948;&lt;sub&gt;&lt;small&gt;k&lt;/sub&gt;&lt;/small&gt;&#947;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 onde V -&gt; &#948;&lt;sub&gt;&lt;small&gt;1&lt;/sub&gt;&lt;/small&gt; | &#948;&lt;sub&gt;&lt;small&gt;2&lt;/sub&gt;&lt;/small&gt; | ... | &#948;&lt;sub&gt;&lt;small&gt;k&lt;/sub&gt;&lt;/small&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        \u00A0\u00A0\u00A0 &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
        &lt;b&gt;fim&lt;/b&gt;&lt;br/&gt;
    </string>
    <string name="lfapp">LFApp:</string>
    <string name="o_lfapp_um_aplicativo_m_vel_para_auxiliar_o_ensino_e_aprendizagem_de_lfa">
        O LFApp é um aplicativo móvel para auxiliar o ensino e aprendizagem de LFA.
    </string>
    <string name="gram_tica">Gramática:</string>
    <string name="o_usu_rio_deve_inserir_uma_gram_tica_com_as_seguintes_configura">
        O usuário deve inserir uma gramática com as seguintes configurações: - Deve iniciar com uma letra maiúscula - O primeiro símbolo será o símbolo inicial - Letras maiúsculas são consideradas variáveis - Letras minúsculas são consideradas terminais
    </string>
    <string name="voltar">Voltar</string>
    <string name="desenvolvido_por_juventino_neto_sob_orienta_o_de_ricardo_terra">
        Desenvolvido por Juventino Neto sob orientação de Ricardo Terra.
    </string>

    <string name="title_activity_fullscreen">FullscreenActivity</string>
    <string name="dummy_button">Dummy Button</string>
    <string name="dummy_content">DUMMY\nCONTENT</string>
    <string name="gram_tica_de_entrada">Gramática de entrada:</string>
    <string name="idGrammar">Identificação da Gramática</string>
    <string name="derivationMostLeft">Derivação Mais à Esquerda</string>
    <string name="removeRecursiveInitialSymbol">Remoção da Recursão no Símbolo Inicial</string>
    <string name="removeEmptyProduction">Remoção de Produções Vazias</string>
    <string name="removeChainRule">Remoção de Regras de Cadeia</string>
    <string name="term">Remoção de Variáveis que Não Geram Terminais</string>
    <string name="reach">Remoção de Símbolos Não Alcançáveis</string>
    <string name="chomskyNormalForm">Forma Normal de Chomsky</string>
    <string name="removeRecursionDirectleft">Remoção de Recursão Direta à Esquerda</string>
    <string name="removeRecursionLeft">Remoção de Recursão Direta e Indireta à Esquerda</string>
    <string name="greibachNormalForm">Forma Normal de Greibach</string>
    <string name="cyk">CYK</string>
    <string name="explanation_grammar_type">A classificação de uma gramática é feita pelo tipo de suas regras (u → v). A tabela abaixo mostra o formato de regras características de cada nível: \n</string>
    <string name="pendente">Pendente.</string>
    <string name="resultado">Resultado:</string>
    <string name="algoritmo">Algoritmo:</string>
    <string name="properties_chomsky_normal_form">Aplicar Propriedades da Forma Normal de Chomsky</string>
    <string name="propertiesGreibachNormalForm">Aplicar Propriedades da Forma Normal de Greibach</string>
    <string name="back">Back</string>
    <string name="next">Next</string>
    <string name="copy">Copiar</string>
    <string name="delete_grammar">Delete grammar.</string>
    <string name="clean_historical_grammar">Limpar histórico</string>
    <string name="m_quina_de_estados">Máquina de Estados</string>
    <string name="hist_rico">Histórico</string>
    <string name="title_activity_regex_to_automata">RegexToAutomataActivity</string>
    <string name="title_activity_automaton_minimization">AutomatonMinimizationActivity</string>
    <string name="automaton_minimization_algol"><![CDATA[Algoritmo\n Entrada: AFD M = (Q, Σ, δ, q0 , F)\n *1 Para todos os pares de estados qi e qj , i < j, faça:\n \t*1.1 D[i, j] = 0\n \t*1.2 S[i, j] = ∅\n *2 Para cada par [i, j], i < j, se um é estado final e o outro não, faça D[i, j] = 1\n *3 Para cada par [i, j], i < j e D[i, j] = 0, faça:\n \t*3.1 se existe um a ∈ Σ tal que δ(qi, a) = qm e δ(qj , a) = qn e (D[m, n] = 1 ou D[n, m] = 1) então:\n \tDIST (i, j) //altera D[i, j] = 1 e propaga a distinção aos elementos de S[i, j]\n \t*3.2 para cada a ∈ Σ tal que (qi , a) = qm e (qj , a) = qn\n \t*se m < n e [i, j] ≠ [m, n], então adicione [i, j] à S[m, n]\n \t*se m > n e [i, j] ≠ [n, m], então adicione [i, j] à S[n, m]\n *4 Para cada D[i, j] = 0, os estados i e j podem ser fundidos\n]]></string>
</resources>
